
public class KdTree {
	private Node root;             // root of KdTree
	private int N;
	private static class Node {
		   private Point2D p;      // the point
		   private RectHV rect;    // the axis-aligned rectangle corresponding to this node
		   private Node lb;        // the left/bottom subtree
		   private Node rt;        // the right/top subtree
		   public Node(Point2D p,RectHV rec ){
			   this.p = p;
			   lb = null;
			   rt = null;
			   rect = rec;
		   }
		}

	public KdTree() {                               // construct an empty set of points
	   N = 0;
	   root = null;
   }
   public boolean isEmpty() {                        // is the set empty?
	   return (size() == 0);
   }
   public int size() {                               // number of points in the set
	   return N;
   }

   
   public void insert(Point2D p) {                   // add the point p to the set (if it is not already in the set)
      if (p == null) { return; }
        root = put(root, p,0,0.0);
   }
   private Node put(Node x, Point2D p, int orientation,double pxy ) {
	   int cmp;
       if (x == null) {
           if ( orientation%2 == 0)
        	   return new Node(p,new RectHV(p.x(),pxy,p.x(),1));
           else
        	   return new Node(p,new RectHV(pxy,p.y(),1,p.y()));
       }
       if ( orientation%2 == 0) {
    	   cmp = Point2D.X_ORDER.compare(p,x.p);
    	   pxy = x.p.x();
       }
       else {
    	   cmp = Point2D.Y_ORDER.compare(p,x.p);
    	   pxy = x.p.y();
       }
	   orientation++;
       if      (cmp < 0) x.lb  = putLeft(x.lb,  p,orientation,0.0,pxy);
       else if (cmp > 0) x.rt = putRight(x.rt, p,orientation,pxy,1.0);
       return x;
   }
   private Node putLeft(Node x, Point2D p, int orientation,double minpxy, double maxpxy ) {
	   int cmp;
	   double xy;
       if (x == null) {
           if ( orientation%2 == 0)
        	   return new Node(p,new RectHV(p.x(),minpxy,p.x(),maxpxy));
           else
        	   return new Node(p,new RectHV(minpxy,p.y(),maxpxy,p.y()));
       }
       if ( orientation%2 == 0) {
    	   cmp = Point2D.X_ORDER.compare(p,x.p);
    	   xy = x.p.x();
       }
       else {
    	   cmp = Point2D.Y_ORDER.compare(p,x.p);
    	   xy = x.p.y();
       }
	   orientation++;
       if      (cmp < 0) x.lb  = putLeft(x.lb,  p,orientation,minpxy,xy);
       else if (cmp > 0) x.rt = putRight(x.rt, p,orientation,xy,maxpxy);
       return x;
	   
   }
   private Node putRight(Node x, Point2D p, int orientation,double minpxy, double maxpxy ) {
	   int cmp;
	   double xy;
       if (x == null) {
           if ( orientation%2 == 0)
        	   return new Node(p,new RectHV(p.x(),minpxy,p.x(),maxpxy));
           else
        	   return new Node(p,new RectHV(minpxy,p.y(),maxpxy,p.y()));
       }
       if ( orientation%2 == 0) {
    	   cmp = Point2D.X_ORDER.compare(p,x.p);
    	   xy = x.p.x();
       }
       else {
    	   cmp = Point2D.Y_ORDER.compare(p,x.p);
    	   xy = x.p.y();
       }
	   orientation++;
       if      (cmp < 0) x.lb  = putLeft(x.lb,  p,orientation,minpxy,xy);
       else if (cmp > 0) x.rt = putRight(x.rt, p,orientation,xy,minpxy);
       return x;
	   
   }

   private Point2D get(Point2D p) {
       return get(root, p,0);
   }

   private Point2D get(Node x, Point2D p,int orientation) {
	   orientation++;
	   int cmp;
       if (x == null) return null;
       if ( orientation%2 == 0)
    	   cmp = Point2D.X_ORDER.compare(p,x.p);
       else
    	   cmp = Point2D.Y_ORDER.compare(p,x.p);
       if      (cmp < 0) return get(x.lb, p,orientation);
       else if (cmp > 0) return get(x.rt, p,orientation);
       else              return x.p;
   }

//   private Iterable<Point2D> points() {
//       Queue<Point2D> queue = new Queue<Point2D>();
//       keys(root,queue);
//       return queue;
//   }

/*   private void keys(Node x, Queue<Point2D> queue) { 
       if (x == null) return; 
       keys(x.lb,queue);
       queue.enqueue(x.p);
       keys(x.rt,queue);
   } 
*/   
   public boolean contains(Point2D p) {             // does the set contain the point p?
	   return get(p) != null;
   }
   public void draw() {                             // draw all of the points to standard draw
//       for (Point2D p : points()) {
//           p.draw();
//       }	   
	   draw(root,0);
   }
   private void draw(Node x,int orientation) {                             // draw all of the points to standard draw
	   if ( x== null) return; 
	   StdDraw.setPenColor(StdDraw.BLACK);
       StdDraw.setPenRadius(.01);	   
	   x.p.draw();
	   if ( orientation%2 == 0)
		   StdDraw.setPenColor(StdDraw.RED);
	   else
		   StdDraw.setPenColor(StdDraw.BLUE);
       StdDraw.setPenRadius(.001);	   
	   x.rect.draw();
	   orientation++;
	   draw(x.lb,orientation);
	   draw(x.rt,orientation);
   }

   
 /*  public Iterable<Point2D> range(RectHV rect){     // all points in the set that are inside the rectangle

   }
   public Point2D nearest(Point2D p) {              // a nearest neighbor in the set to p; null if set is empty

   } */
   public static void main(String[] args) {
	   KdTree pset = new KdTree();
	   StdDraw.setPenColor(StdDraw.BLACK);
	   StdDraw.setPenRadius(.01);
       for (int i = 0; i < 10; i++) {
           double x = StdRandom.uniform();
           double y = StdRandom.uniform();
           pset.insert(new Point2D(x, y) );
       }	   
       pset.draw();
   }   
   }
